/**
 * Copyright 2017-2022 LinkedIn Corporation. All rights reserved.
 * Licensed under the BSD-2 Clause license.
 * See LICENSE in the project root for license information.
 */
package com.linkedin.coral.transformers;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.calcite.config.NullCollation;
import org.apache.calcite.rel.BiRel;
import org.apache.calcite.rel.RelNode;
import org.apache.calcite.rel.core.Correlate;
import org.apache.calcite.rel.core.Join;
import org.apache.calcite.rel.core.JoinRelType;
import org.apache.calcite.rel.core.Project;
import org.apache.calcite.rel.core.TableScan;
import org.apache.calcite.rel.core.Uncollect;
import org.apache.calcite.rel.logical.LogicalTableFunctionScan;
import org.apache.calcite.rel.rel2sql.RelToSqlConverter;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.rex.RexCall;
import org.apache.calcite.rex.RexCorrelVariable;
import org.apache.calcite.rex.RexFieldAccess;
import org.apache.calcite.rex.RexNode;
import org.apache.calcite.sql.JoinConditionType;
import org.apache.calcite.sql.JoinType;
import org.apache.calcite.sql.SqlCall;
import org.apache.calcite.sql.SqlDialect;
import org.apache.calcite.sql.SqlIdentifier;
import org.apache.calcite.sql.SqlJoin;
import org.apache.calcite.sql.SqlKind;
import org.apache.calcite.sql.SqlLateralOperator;
import org.apache.calcite.sql.SqlLiteral;
import org.apache.calcite.sql.SqlNode;
import org.apache.calcite.sql.SqlOperator;
import org.apache.calcite.sql.fun.SqlStdOperatorTable;
import org.apache.calcite.sql.parser.SqlParserPos;
import org.apache.calcite.sql.type.SqlTypeName;

import com.linkedin.coral.com.google.common.collect.ImmutableList;
import com.linkedin.coral.com.google.common.collect.ImmutableMap;
import com.linkedin.coral.common.functions.CoralSqlUnnestOperator;


/**
 * This class converts a Coral intermediate representation, CoralRelNode, to CoralSqlNode.
 */
public class CoralRelToSqlNodeConverter extends RelToSqlConverter {

  public static final SqlDialect INSTANCE = returnInstance();

  /**
   * Creates a CoralRelToSqlNodeConverter.
   */
  public CoralRelToSqlNodeConverter() {
    super(INSTANCE);
  }

  /**
   * Converts a CoralRelNode to its CoralSqlNode representation.
   * @param coralRelNode Coral intermediate representation.
   * @return Result of converting the RelNode to a SqlNode.
   */
  public SqlNode convert(RelNode coralRelNode) {
    return visitChild(0, coralRelNode).asStatement();
  }

  private static SqlDialect returnInstance() {
    SqlDialect.Context context = SqlDialect.EMPTY_CONTEXT.withDatabaseProduct(SqlDialect.DatabaseProduct.HIVE)
        .withNullCollation(NullCollation.HIGH);

    return new SqlDialect(context);
  }

  /**
   * TableScan RelNode represents a relational operator that returns the contents of a table.
   * Super's implementation generates a table namespace with the catalog, schema, and table name.
   * This overriding implementation removes the catalog name from the table namespace, if present.
   *
   * @param e TableScan RelNode. An example:
   *         <pre>
   *            LogicalTableScan(table=[[hive, default, complex]])
   *         </pre>
   *
   * @return Result of converting the RelNode to a SqlNode.
   *         The SqlNode generated by converting the above RelNode example is:
   *        <pre>
   *               (SqlIdentifier)
   *            names: `default`.`complex`
   *        </pre>
   */
  @Override
  public Result visit(TableScan e) {
    List<String> qualifiedName = e.getTable().getQualifiedName();
    if (qualifiedName.size() > 2) {
      qualifiedName = qualifiedName.subList(qualifiedName.size() - 2, qualifiedName.size());
    }
    final SqlIdentifier identifier = new SqlIdentifier(qualifiedName, SqlParserPos.ZERO);
    return result(identifier, ImmutableList.of(Clause.FROM), e, null);
  }


  /**
   * Custom table-valued functions are represented as LogicalTableFunctionScan type relational expression.
   * Current version of Calcite used in Coral does not implement traversing
   * a LogicalTableFunctionScan type RelNode. Hence, this implementation is added.
   *
   * @param e RelNode of type LogicalTableFunctionScan as input. Example:
   *           <pre>
   *             LogicalTableFunctionScan(invocation=[foo_udtf_CountOfRow($cor0.a)])
   *           </pre>
   *
   * @return Result of converting the RelNode to a SqlNode.
   *         The conversion result of the above example is:
   *         The SqlNode generated by converting the above RelNode example is:
   *         <pre>
   *                                (SqlBasicCall)
   *          COLLECTION_TABLE(`foo_udtf_CountOfRow`(`complex`.`a`))
   *                                     |
   *            _________________________|__________________________
   *           |                                                   |
   *  Operator: COLLECTION_TABLE               Operand: `foo_udtf_CountOfRow`(`complex`.`a`)
   *                                                              |
   *                                             _________________|______________________
   *                                            |                                       |
   *                             Operator: foo_udtf_CountOfRow               Operand: `complex`.`a`
   *         </pre>
   */
  public Result visit(LogicalTableFunctionScan e) {
    RexCall call = (RexCall) e.getCall();
    SqlOperator functionOperator = call.getOperator();
    final List<SqlNode> functionOperands = new ArrayList<>();
    for (RexNode rexOperand : call.getOperands()) {
      RexFieldAccess rexFieldAccess = (RexFieldAccess) rexOperand;
      RexCorrelVariable rexCorrelVariable = (RexCorrelVariable) rexFieldAccess.getReferenceExpr();
      SqlNode sqlNodeOperand = correlTableMap.get(rexCorrelVariable.id).toSql(null, rexOperand);
      functionOperands.add(sqlNodeOperand);
    }

    SqlCall functionSqlCall = functionOperator.createCall(POS, functionOperands.toArray(new SqlNode[0]));

    SqlNode tableCall = new SqlLateralOperator(SqlKind.COLLECTION_TABLE).createCall(POS, functionSqlCall);

    Result tableCallResultWithAlias = result(tableCall, ImmutableList.of(Clause.FROM), e, null);

    return new Result(tableCall, ImmutableList.of(Clause.FROM), null, e.getRowType(),
        ImmutableMap.of(tableCallResultWithAlias.neededAlias, e.getRowType()));
  }

  /**
   * Join represents a RelNode with two child relational expressions linked by a join type.
   * Super's implementation uses the conversion result of the right child as is.
   * When the right child of a Join node is an Uncollect / TableFunction type RelNode,
   * this overriding implementation introduces LATERAL and AS operators as parents of the conversion result of the right child.
   *
   * @param e RelNode of type Join with two child nodes as input. Example:
   *        <pre>
   *                             LogicalJoin(condition=[true], joinType=[inner])
   *                                /                                      \
   *    LogicalTableScan(table=[[hive, default, complex]])              HiveUncollect
   *                                                                         \
   *           			          			                        		  	LogicalProject(col=[$cor0.c])
   *                                                                           \
   *           			          			         			          			 	LogicalValues(tuples=[[{ 0 }]])
   *        </pre>
   *
   * @return Result of converting the RelNode to a SqlNode.
   *        The SqlNode generated by converting the above RelNode example is:
   *        <pre>
   *                                      (SqlCall)
   *          SqlJoin[`default`.`complex` , LATERAL UNNEST(`complex`.`c`) AS `t_alias` (`col_alias`)]
   *                                         |
   *                _________________________|_____________________________
   *               |                         |                            |
   *  left: `default`.`complex`         joinType: ,       right: LATERAL UNNEST(`complex`.`c`) AS `t_alias` (`col_alias`)
   *
   *        </pre>
   */
  @Override
  public Result visit(Join e) {
    Result leftResult = this.visitChild(0, e.getLeft()).resetAlias();
    Result rightResult = this.visitChild(1, e.getRight()).resetAlias();
    Context leftContext = leftResult.qualifiedContext();
    Context rightContext = rightResult.qualifiedContext();
    SqlNode sqlCondition = null;
    SqlLiteral condType = JoinConditionType.ON.symbol(POS);
    JoinType joinType = joinType(e.getJoinType());

    if (e.getJoinType() == JoinRelType.INNER && e.getCondition().isAlwaysTrue()) {
      joinType = dialect.emulateJoinTypeForCrossJoin();
      condType = JoinConditionType.NONE.symbol(POS);
    } else {
      sqlCondition = convertConditionToSqlNode(e.getCondition(), leftContext, rightContext,
          e.getLeft().getRowType().getFieldCount());
    }

    SqlNode rightSqlNode = rightResult.asFrom();

    if (e.getRight() instanceof LogicalTableFunctionScan || e.getRight() instanceof Uncollect) {
      rightSqlNode = generateRightChildForSqlJoinWithLateralViews(e, rightResult);
    }

    SqlNode join = new SqlJoin(POS, leftResult.asFrom(), SqlLiteral.createBoolean(false, POS), joinType.symbol(POS),
        rightSqlNode, condType, sqlCondition);

    return result(join, leftResult, rightResult);
  }

  private SqlNode generateRightChildForSqlJoinWithLateralViews(BiRel e, Result rightResult) {
    SqlNode rightSqlNode = rightResult.asFrom();

    final SqlNode rightLateral = SqlStdOperatorTable.LATERAL.createCall(POS, rightSqlNode);

    // Append the alias to unnestCall by generating SqlCall with AS operator
    RelDataType relDataType = e.getRight().getRowType();
    String alias = rightResult.aliases.entrySet().stream().filter(entry -> relDataType.equals(entry.getValue()))
        .findFirst().map(Map.Entry::getKey).orElse("coralDefaultColumnAlias");

    List<SqlNode> asOperands = createAsFullOperands(relDataType, rightLateral, alias);

    return SqlStdOperatorTable.AS.createCall(POS, asOperands);
  }
}
